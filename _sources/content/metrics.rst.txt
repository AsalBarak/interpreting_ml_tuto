.. note::
    :class: sphx-glr-download-link-note

    Click :ref:`here <sphx_glr_download_content_metrics.py>` to download the full example code or run this example in your browser via Binder
.. rst-class:: sphx-glr-example-title

.. _sphx_glr_content_metrics.py:


Metrics to judge the sucess of a model
=======================================

Pro & cons of various performance metrics.

.. contents::

The simple way to use a scoring metric during cross-validation is
via the `scoring` parameter of
:func:`sklearn.model_selection.cross_val_score`.


Regression settings
-----------------------

The Boston housing data
........................



.. code-block:: python


    from sklearn import datasets
    boston = datasets.load_boston()

    # Shuffle the data
    from sklearn.utils import shuffle
    data, target = shuffle(boston.data, boston.target, random_state=0)







A quick plot of how each feature is related to the target



.. code-block:: python

    from matplotlib import pyplot as plt

    for feature, name in zip(data.T, boston.feature_names):
        plt.figure(figsize=(4, 3))
        plt.scatter(feature, target)
        plt.xlabel(name, size=22)
        plt.ylabel('Price (US$)', size=22)
        plt.tight_layout()




.. rst-class:: sphx-glr-horizontal


    *

      .. image:: /content/images/sphx_glr_metrics_001.png
            :class: sphx-glr-multi-img

    *

      .. image:: /content/images/sphx_glr_metrics_002.png
            :class: sphx-glr-multi-img

    *

      .. image:: /content/images/sphx_glr_metrics_003.png
            :class: sphx-glr-multi-img

    *

      .. image:: /content/images/sphx_glr_metrics_004.png
            :class: sphx-glr-multi-img

    *

      .. image:: /content/images/sphx_glr_metrics_005.png
            :class: sphx-glr-multi-img

    *

      .. image:: /content/images/sphx_glr_metrics_006.png
            :class: sphx-glr-multi-img

    *

      .. image:: /content/images/sphx_glr_metrics_007.png
            :class: sphx-glr-multi-img

    *

      .. image:: /content/images/sphx_glr_metrics_008.png
            :class: sphx-glr-multi-img

    *

      .. image:: /content/images/sphx_glr_metrics_009.png
            :class: sphx-glr-multi-img

    *

      .. image:: /content/images/sphx_glr_metrics_010.png
            :class: sphx-glr-multi-img

    *

      .. image:: /content/images/sphx_glr_metrics_011.png
            :class: sphx-glr-multi-img

    *

      .. image:: /content/images/sphx_glr_metrics_012.png
            :class: sphx-glr-multi-img

    *

      .. image:: /content/images/sphx_glr_metrics_013.png
            :class: sphx-glr-multi-img




We will be using a random forest regressor to predict the price



.. code-block:: python

    from sklearn.ensemble import RandomForestRegressor
    regressor = RandomForestRegressor()







Explained variance vs Mean Square Error
.......................................

The default score is explained variance



.. code-block:: python

    from sklearn.model_selection import cross_val_score
    print(cross_val_score(regressor, data, target))





.. rst-class:: sphx-glr-script-out

 Out::

    [ 0.79909671  0.84516593  0.81727035]


Explained variance is convienent because it has a natural scaling: 1 is
perfect prediction, and 0 is around chance

Now let us see which houses are easier to predict:

Not along the Charles river (feature 3)



.. code-block:: python

    print(cross_val_score(regressor, data[data[:, 3] == 0],
                          target[data[:, 3] == 0]))





.. rst-class:: sphx-glr-script-out

 Out::

    [ 0.76822789  0.89762207  0.82581889]


Along the Charles river



.. code-block:: python

    print(cross_val_score(regressor, data[data[:, 3] == 1],
                          target[data[:, 3] == 1]))





.. rst-class:: sphx-glr-script-out

 Out::

    [ 0.63024554 -0.03537074  0.58345236]


So the houses along the Charles are harder to predict?

It's not so easy to conclude this from the explained variance: in two
different sets of observations, the variance of the target differs, and
the explained variance is a relative measure

**MSE**: We can use the mean squared error (here negated)

Not along the Charles river



.. code-block:: python

    print(cross_val_score(regressor, data[data[:, 3] == 0],
                          target[data[:, 3] == 0],
                          scoring='neg_mean_squared_error'))





.. rst-class:: sphx-glr-script-out

 Out::

    [-12.15537197  -8.50765414 -15.33496178]


Along the Charles river



.. code-block:: python

    print(cross_val_score(regressor, data[data[:, 3] == 1],
                          target[data[:, 3] == 1],
                          scoring='neg_mean_squared_error'))





.. rst-class:: sphx-glr-script-out

 Out::

    [ -76.33384167 -132.695325    -77.19796364]


So the error is larger along the Charles river


Mean Squared Error versus Mean Absolute Error
..................................................

What if we want to report an error in dollars, meaningful for an
application?

The Mean Absolute Error is useful for this goal



.. code-block:: python

    print(cross_val_score(regressor, data, target,
                          scoring='neg_mean_absolute_error'))





.. rst-class:: sphx-glr-script-out

 Out::

    [-2.50686391 -2.33946746 -2.61470238]


Summary
.........

* **explained variance**: scaled with regards to chance: 1 = perfect,
  0 = around chance, but it shouldn't used to compare predictions
  across datasets

* **mean absolute error**: enables comparison across datasets in the
  units of the target


Classification settings
-----------------------

The digits data
.................



.. code-block:: python

    digits = datasets.load_digits()
    # Let us try to detect sevens:
    sevens = (digits.target == 7)

    from sklearn.ensemble import RandomForestClassifier
    classifier = RandomForestClassifier()







Accuracy and its shortcomings
.............................

The default metric is the accuracy: the averaged fraction of success.
It takes values between 0 and 1, where 1 is perfect prediction



.. code-block:: python

    print(cross_val_score(classifier, digits.data, sevens))





.. rst-class:: sphx-glr-script-out

 Out::

    [ 0.97166667  0.97328881  0.97826087]


However, a stupid classifier can each good prediction wit imbalanced
classes



.. code-block:: python

    from sklearn.dummy import DummyClassifier
    dummy = DummyClassifier(strategy='most_frequent')
    print(cross_val_score(dummy, digits.data, sevens))





.. rst-class:: sphx-glr-script-out

 Out::

    [ 0.9         0.89983306  0.90133779]


Balanced accuracy (available in development scikit-learn versions)
fixes this, but can have surprising behaviors, such as being negative


Precision, recall, and their shortcomings
..........................................

We can measure separately false detection and misses

**Precision**: Precision counts the ratio of detections that are
correct



.. code-block:: python

    print(cross_val_score(classifier, digits.data, sevens,
                          scoring='precision'))




.. rst-class:: sphx-glr-script-out

 Out::

    [ 0.97826087  0.94545455  0.94545455]


Our classifier has a good precision: most of the sevens that it
predicts are really sevens.

As predicting the most frequent never predicts sevens, precision is ill
defined. Scikit-learn puts it to zero



.. code-block:: python

    print(cross_val_score(dummy, digits.data, sevens, scoring='precision'))






.. rst-class:: sphx-glr-script-out

 Out::

    [ 0.  0.  0.]


**Recall**: Recall counts the fraction of class 1 actually detected



.. code-block:: python

    print(cross_val_score(classifier, digits.data, sevens, scoring='recall'))





.. rst-class:: sphx-glr-script-out

 Out::

    [ 0.7         0.83333333  0.89830508]


Our recall isn't as good: we miss many sevens

But predicting the most frequent never predicts sevens:



.. code-block:: python

    print(cross_val_score(dummy, digits.data, sevens, scoring='recall'))





.. rst-class:: sphx-glr-script-out

 Out::

    [ 0.  0.  0.]


**Note**: Measuring only the precision without the recall makes no
sense, it is easy to maximize one at the cost of the other. Ideally,
classifiers should be compared on a precision at a given recall


Area under the ROC curve
..........................

If the classifier provides a decision function that can be thresholded
to control false positives versus false negatives, the ROC curve
summarise the different tradeoffs that can be achieved by varying this
threshold.

Its Area Under the Curve (AUC) is a useful metric where 1 is perfect
prediction and .5 is chance, independently of class imbalance



.. code-block:: python

    print(cross_val_score(classifier, digits.data, sevens, scoring='roc_auc'))





.. rst-class:: sphx-glr-script-out

 Out::

    [ 0.99945988  0.99465059  0.99770447]



.. code-block:: python

    print(cross_val_score(dummy, digits.data, sevens, scoring='roc_auc'))






.. rst-class:: sphx-glr-script-out

 Out::

    [ 0.5  0.5  0.5]


Average precision
..................


Multiclass and multilabel settings
...................................


**Total running time of the script:** ( 0 minutes  1.881 seconds)


.. _sphx_glr_download_content_metrics.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example


  .. container:: binder-badge

    .. image:: https://static.mybinder.org/badge.svg
      :target: https://mybinder.org/v2/gh/gaelvaroquaux/interpreting_ml_tuto/master?filepath=_downloads/metrics.ipynb
      :width: 150 px


  .. container:: sphx-glr-download

     :download:`Download Python source code: metrics.py <metrics.py>`



  .. container:: sphx-glr-download

     :download:`Download Jupyter notebook: metrics.ipynb <metrics.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.readthedocs.io>`_
